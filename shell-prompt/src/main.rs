use anyhow::Result;
use portable_pty::{CommandBuilder, NativePtySystem, PtySize, PtySystem};
use std::io::{Read, Write};
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

struct PtyDriver {
    rx: mpsc::Receiver<Vec<u8>>,
    buffer: String,
}

impl PtyDriver {
    fn new(rx: mpsc::Receiver<Vec<u8>>) -> Self {
        Self {
            rx,
            buffer: String::new(),
        }
    }

    fn read_until(&mut self, marker: &str) -> Result<String> {
        let timeout = Duration::from_secs(5);
        let start = std::time::Instant::now();

        loop {
            // Check if marker is already in buffer
            if let Some(pos) = self.buffer.find(marker) {
                let content = self.buffer[..pos].to_string();
                // Advance buffer past the marker
                self.buffer = self.buffer[pos + marker.len()..].to_string();
                return Ok(content);
            }

            // Check timeout
            if start.elapsed() >= timeout {
                return Err(anyhow::anyhow!(
                    "Timeout waiting for marker '{}'. Buffer: {:?}",
                    marker,
                    self.buffer
                ));
            }

            // Read more
            match self.rx.recv_timeout(Duration::from_millis(50)) {
                Ok(data) => {
                    self.buffer.push_str(&String::from_utf8_lossy(&data));
                }
                Err(mpsc::RecvTimeoutError::Timeout) => {
                    continue; // Just loop to check overall timeout
                }
                Err(_) => return Err(anyhow::anyhow!("Channel closed")),
            }
        }
    }

    // New helper: Read until silence (no data for a period)
    fn read_until_idle(&mut self, wait: Duration) -> Result<String> {
        let mut collected = String::new();

        // Loop to consume whatever is currently available and arriving
        loop {
            // If we already have data in buffer, move it to collected
            if !self.buffer.is_empty() {
                collected.push_str(&self.buffer);
                self.buffer.clear();
            }

            // Try to receive more with a short timeout
            match self.rx.recv_timeout(wait) {
                Ok(data) => {
                    self.buffer.push_str(&String::from_utf8_lossy(&data));
                    // Loop again to consume this and check for more
                }
                Err(mpsc::RecvTimeoutError::Timeout) => {
                    // Idle detected
                    break;
                }
                Err(_) => return Err(anyhow::anyhow!("Channel closed")),
            }
        }

        Ok(collected)
    }
}

fn main() -> Result<()> {
    let pty_system = NativePtySystem::default();
    let pair = pty_system.openpty(PtySize {
        rows: 24,
        cols: 120, // Wider to avoid wrapping issues
        pixel_width: 0,
        pixel_height: 0,
    })?;

    let mut cmd_builder = CommandBuilder::new("bash");
    // We keep --noprofile --norc to have a predictable shell, but we WON'T force PS1
    cmd_builder.args(&["--noprofile", "--norc"]);
    cmd_builder.env("TERM", "dumb");

    let _child = pair.slave.spawn_command(cmd_builder)?;
    let mut writer = pair.master.take_writer()?;
    let reader = pair.master.try_clone_reader()?;

    let (tx, rx) = mpsc::channel();
    let mut reader = reader;
    thread::spawn(move || {
        let mut buf = [0u8; 1024];
        loop {
            match reader.read(&mut buf) {
                Ok(n) if n > 0 => {
                    let _ = tx.send(buf[..n].to_vec());
                }
                _ => break,
            }
        }
    });

    // Driver manages the buffer
    let mut driver = PtyDriver::new(rx);

    // Initial delay
    thread::sleep(Duration::from_millis(200));

    // Turn off echo to simplify parsing
    writeln!(writer, "stty -echo")?;
    // Capture the stty command echo itself (if any) and clear buffer
    let _ = driver.read_until_idle(Duration::from_millis(200))?;

    // Defien Custom Prompt: user@hostname:cwd ($ for user)
    writeln!(writer, "export PS1='\\u@\\h:\\w$ '")?;

    // Sync to clear any residue and ensure we are ready
    let sync_token = "___SYNC_TOKEN___";
    writeln!(writer, "echo '{}'", sync_token)?;

    // Consume until SYNC output. 
    // Since echo is off, we won't see "echo ___SYNC_TOKEN___", only the output "___SYNC_TOKEN___"
    // Also this consumes the intermediate prompt generated by the export PS1 command.
    let _ = driver.read_until(sync_token)?;
    // Consume the newline after token + prompt
    let initial_prompt = driver.read_until_idle(Duration::from_millis(100))?;

    println!("Shell initialized with custom prompt (user@hostname:pwd).");
    
    let mut last_prompt = initial_prompt;

    let commands = vec![
        "echo 'Hello World'",
        "ls -F", 
        "cat non_existent_file",
        "sleep 1 && echo 'Delayed'",
    ];

    for cmd in commands {
        let result = run_command(&mut writer, &mut driver, cmd)?;
        
        println!("----- Native Shell Content -----");
        // Print [Prompt] [Command]
        // Note: prompt usually doesn't have a newline at the end, but might have one at start if not cleaned.
        // We trim_start to avoid accumulated newlines, but keep end spaces.
        print!("{}{}\n", last_prompt.trim_start(), cmd);
        
        // Print Output
        if !result.output.is_empty() {
             println!("{}", result.output); 
        }
        
        // Print New Prompt (trailing)
        println!("{}", result.prompt.trim()); 
        
        println!("----- Parsed Content -----");
        println!("Command:   {}", result.cmd);
        println!("Exit Code: {}", result.exit_code);
        println!("Prompt:    {:?}", result.prompt.trim());
        println!("Output:    \n{}", result.output.trim());
        println!(""); // Empty line for separation

        last_prompt = result.prompt;
    }


    Ok(())
}

struct CommandResult {
    cmd: String,
    output: String,
    prompt: String,
    exit_code: i32,
}

fn run_command(
    writer: &mut Box<dyn Write + Send>,
    driver: &mut PtyDriver,
    cmd: &str,
) -> Result<CommandResult> {
    let exit_marker = "EXIT_CODE:";
    // Construct command
    let cmd_line = format!("{}; echo \"{}{}$?\"", cmd, exit_marker, "");
    // ls; echo "EXIT_CODE:$?"
    writeln!(writer, "{}", cmd_line)?;

    // 1. Read until the marker ("EXIT_CODE:"). The content before is the command output (plus echo).
    let raw_output = driver.read_until(exit_marker)?;

    // 2. Read the exit code. We expect "N\r\n" or similar.
    // simpler: read until logical newline.
    // In raw mode, it's usually \r\n.
    let raw_exit_line = driver.read_until("\n")?; // Captures "0\r" if line ended in \r\n

    // 3. What remains is the prompt. Wait for it to settle.
    let prompt_raw = driver.read_until_idle(Duration::from_millis(100))?;

    // Parse logic

    // Parse Exit Code
    let exit_code = raw_exit_line.trim().parse::<i32>().unwrap_or(-1);

    // Parse Output
    // raw_output contains: "cmd line\r\nOutput..."
    let output_parsed = parse_output_only(&raw_output, cmd);

    Ok(CommandResult {
        cmd: cmd.to_string(),
        output: output_parsed,
        prompt: prompt_raw, // Keep raw prompt or trim? User asked to parse it out.
        exit_code,
    })
}

fn parse_output_only(raw: &str, _original_cmd_hint: &str) -> String {
    // With stty -echo, raw contains only the command output (and trailing newlines).
    // We just need to trim the specific newline that echo might leave,
    // but usually run_command logic splits explicitly at EXIT_CODE:

    // raw comes from: read_until("EXIT_CODE:")
    // If command was `echo hello`, output is `hello\n`
    // followed by `EXIT_CODE:...`

    // So raw is `hello\n`.
    // It might also contain `\r\n`.

    raw.trim_end().to_string()
}

// Remove old parse_raw_content since we logic moved to run_command
